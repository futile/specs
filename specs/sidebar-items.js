initSidebarItems({"struct":[["CreateEntityIter","Entity creation iterator. Will yield new empty entities infinitely. Useful for bulk entity construction, since the locks are only happening once."],["DynamicEntityIter","A custom entity iterator for dynamically added entities."],["Entity","Entity type, as seen by the user."],["EntityBuilder","Helper builder for entities."],["EntityIter","A custom entity iterator. Needed because the world doesn't really store entities directly, but rather has just a vector of Index -> Generation."],["FetchArg","System fetch-time argument. The fetch is executed at the start of the run. It contains a subset of World methods that make sense during initialization."],["HashMapStorage","HashMap-based storage. Best suited for rare components."],["Planner","System execution planner. Allows running systems via closures, distributes the load in parallel using a thread pool."],["RunArg","System closure run-time argument."],["VecStorage","Vec-based storage, actually wraps data into options and stores the generations of the data in order to match with given entities. Supposed to have maximum performance for the components mostly present in entities."],["World","The world struct contains all the data, which is entities and their components. The methods are supposed to be valid for any context they are available in."]],"trait":[["Component","Abstract component type. Doesn't have to be Copy or even Clone."],["Storage","Typed component storage trait."],["StorageBase","Base trait for a component storage that is used as a trait object. Doesn't depent on the actual component type."]],"type":[["Generation","Index generation. When a new entity is placed at the old index, it bumps the generation by 1. This allows to avoid using components from the entities that were deleted. G<=0 - the entity of generation G is dead G >0 - the entity of generation G is alive"],["Index","Index type is arbitrary. It doesn't show up in any interfaces. Keeping it 32bit allows for a single 64bit word per entity."]]});